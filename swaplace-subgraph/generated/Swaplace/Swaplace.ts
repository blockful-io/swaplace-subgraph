// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class SwapAccepted extends ethereum.Event {
  get params(): SwapAccepted__Params {
    return new SwapAccepted__Params(this);
  }
}

export class SwapAccepted__Params {
  _event: SwapAccepted;

  constructor(event: SwapAccepted) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get accepter(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class SwapCanceled extends ethereum.Event {
  get params(): SwapCanceled__Params {
    return new SwapCanceled__Params(this);
  }
}

export class SwapCanceled__Params {
  _event: SwapCanceled;

  constructor(event: SwapCanceled) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get canceler(): Address {
    return this._event.parameters[1].value.toAddress();
  }
}

export class SwapCreated extends ethereum.Event {
  get params(): SwapCreated__Params {
    return new SwapCreated__Params(this);
  }
}

export class SwapCreated__Params {
  _event: SwapCreated;

  constructor(event: SwapCreated) {
    this._event = event;
  }

  get id(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get owner(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get expiry(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Swaplace__createSwapInputSwapStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get allowed(): Address {
    return this[1].toAddress();
  }

  get expiry(): BigInt {
    return this[2].toBigInt();
  }

  get biding(): Array<Swaplace__createSwapInputSwapBidingStruct> {
    return this[3].toTupleArray<Swaplace__createSwapInputSwapBidingStruct>();
  }

  get asking(): Array<Swaplace__createSwapInputSwapAskingStruct> {
    return this[4].toTupleArray<Swaplace__createSwapInputSwapAskingStruct>();
  }
}

export class Swaplace__createSwapInputSwapBidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__createSwapInputSwapAskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__getSwapResultValue0Struct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get allowed(): Address {
    return this[1].toAddress();
  }

  get expiry(): BigInt {
    return this[2].toBigInt();
  }

  get biding(): Array<Swaplace__getSwapResultValue0BidingStruct> {
    return this[3].toTupleArray<Swaplace__getSwapResultValue0BidingStruct>();
  }

  get asking(): Array<Swaplace__getSwapResultValue0AskingStruct> {
    return this[4].toTupleArray<Swaplace__getSwapResultValue0AskingStruct>();
  }
}

export class Swaplace__getSwapResultValue0BidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__getSwapResultValue0AskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeAssetResultValue0Struct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapResultValue0Struct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get allowed(): Address {
    return this[1].toAddress();
  }

  get expiry(): BigInt {
    return this[2].toBigInt();
  }

  get biding(): Array<Swaplace__makeSwapResultValue0BidingStruct> {
    return this[3].toTupleArray<Swaplace__makeSwapResultValue0BidingStruct>();
  }

  get asking(): Array<Swaplace__makeSwapResultValue0AskingStruct> {
    return this[4].toTupleArray<Swaplace__makeSwapResultValue0AskingStruct>();
  }
}

export class Swaplace__makeSwapResultValue0BidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapResultValue0AskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapInputBidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace__makeSwapInputAskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class Swaplace extends ethereum.SmartContract {
  static bind(address: Address): Swaplace {
    return new Swaplace("Swaplace", address);
  }

  acceptSwap(id: BigInt): boolean {
    let result = super.call("acceptSwap", "acceptSwap(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);

    return result[0].toBoolean();
  }

  try_acceptSwap(id: BigInt): ethereum.CallResult<boolean> {
    let result = super.tryCall("acceptSwap", "acceptSwap(uint256):(bool)", [
      ethereum.Value.fromUnsignedBigInt(id)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  createSwap(swap: Swaplace__createSwapInputSwapStruct): BigInt {
    let result = super.call(
      "createSwap",
      "createSwap((address,address,uint256,(address,uint256)[],(address,uint256)[])):(uint256)",
      [ethereum.Value.fromTuple(swap)]
    );

    return result[0].toBigInt();
  }

  try_createSwap(
    swap: Swaplace__createSwapInputSwapStruct
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "createSwap",
      "createSwap((address,address,uint256,(address,uint256)[],(address,uint256)[])):(uint256)",
      [ethereum.Value.fromTuple(swap)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  getSwap(id: BigInt): Swaplace__getSwapResultValue0Struct {
    let result = super.call(
      "getSwap",
      "getSwap(uint256):((address,address,uint256,(address,uint256)[],(address,uint256)[]))",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );

    return changetype<Swaplace__getSwapResultValue0Struct>(result[0].toTuple());
  }

  try_getSwap(
    id: BigInt
  ): ethereum.CallResult<Swaplace__getSwapResultValue0Struct> {
    let result = super.tryCall(
      "getSwap",
      "getSwap(uint256):((address,address,uint256,(address,uint256)[],(address,uint256)[]))",
      [ethereum.Value.fromUnsignedBigInt(id)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Swaplace__getSwapResultValue0Struct>(value[0].toTuple())
    );
  }

  makeAsset(
    addr: Address,
    amountOrId: BigInt
  ): Swaplace__makeAssetResultValue0Struct {
    let result = super.call(
      "makeAsset",
      "makeAsset(address,uint256):((address,uint256))",
      [
        ethereum.Value.fromAddress(addr),
        ethereum.Value.fromUnsignedBigInt(amountOrId)
      ]
    );

    return changetype<Swaplace__makeAssetResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_makeAsset(
    addr: Address,
    amountOrId: BigInt
  ): ethereum.CallResult<Swaplace__makeAssetResultValue0Struct> {
    let result = super.tryCall(
      "makeAsset",
      "makeAsset(address,uint256):((address,uint256))",
      [
        ethereum.Value.fromAddress(addr),
        ethereum.Value.fromUnsignedBigInt(amountOrId)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Swaplace__makeAssetResultValue0Struct>(value[0].toTuple())
    );
  }

  makeSwap(
    owner: Address,
    allowed: Address,
    expiry: BigInt,
    biding: Array<Swaplace__makeSwapInputBidingStruct>,
    asking: Array<Swaplace__makeSwapInputAskingStruct>
  ): Swaplace__makeSwapResultValue0Struct {
    let result = super.call(
      "makeSwap",
      "makeSwap(address,address,uint256,(address,uint256)[],(address,uint256)[]):((address,address,uint256,(address,uint256)[],(address,uint256)[]))",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(allowed),
        ethereum.Value.fromUnsignedBigInt(expiry),
        ethereum.Value.fromTupleArray(biding),
        ethereum.Value.fromTupleArray(asking)
      ]
    );

    return changetype<Swaplace__makeSwapResultValue0Struct>(
      result[0].toTuple()
    );
  }

  try_makeSwap(
    owner: Address,
    allowed: Address,
    expiry: BigInt,
    biding: Array<Swaplace__makeSwapInputBidingStruct>,
    asking: Array<Swaplace__makeSwapInputAskingStruct>
  ): ethereum.CallResult<Swaplace__makeSwapResultValue0Struct> {
    let result = super.tryCall(
      "makeSwap",
      "makeSwap(address,address,uint256,(address,uint256)[],(address,uint256)[]):((address,address,uint256,(address,uint256)[],(address,uint256)[]))",
      [
        ethereum.Value.fromAddress(owner),
        ethereum.Value.fromAddress(allowed),
        ethereum.Value.fromUnsignedBigInt(expiry),
        ethereum.Value.fromTupleArray(biding),
        ethereum.Value.fromTupleArray(asking)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<Swaplace__makeSwapResultValue0Struct>(value[0].toTuple())
    );
  }

  supportsInterface(interfaceID: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceID)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceID: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceID)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  swapId(): BigInt {
    let result = super.call("swapId", "swapId():(uint256)", []);

    return result[0].toBigInt();
  }

  try_swapId(): ethereum.CallResult<BigInt> {
    let result = super.tryCall("swapId", "swapId():(uint256)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class AcceptSwapCall extends ethereum.Call {
  get inputs(): AcceptSwapCall__Inputs {
    return new AcceptSwapCall__Inputs(this);
  }

  get outputs(): AcceptSwapCall__Outputs {
    return new AcceptSwapCall__Outputs(this);
  }
}

export class AcceptSwapCall__Inputs {
  _call: AcceptSwapCall;

  constructor(call: AcceptSwapCall) {
    this._call = call;
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class AcceptSwapCall__Outputs {
  _call: AcceptSwapCall;

  constructor(call: AcceptSwapCall) {
    this._call = call;
  }

  get value0(): boolean {
    return this._call.outputValues[0].value.toBoolean();
  }
}

export class CancelSwapCall extends ethereum.Call {
  get inputs(): CancelSwapCall__Inputs {
    return new CancelSwapCall__Inputs(this);
  }

  get outputs(): CancelSwapCall__Outputs {
    return new CancelSwapCall__Outputs(this);
  }
}

export class CancelSwapCall__Inputs {
  _call: CancelSwapCall;

  constructor(call: CancelSwapCall) {
    this._call = call;
  }

  get id(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class CancelSwapCall__Outputs {
  _call: CancelSwapCall;

  constructor(call: CancelSwapCall) {
    this._call = call;
  }
}

export class CreateSwapCall extends ethereum.Call {
  get inputs(): CreateSwapCall__Inputs {
    return new CreateSwapCall__Inputs(this);
  }

  get outputs(): CreateSwapCall__Outputs {
    return new CreateSwapCall__Outputs(this);
  }
}

export class CreateSwapCall__Inputs {
  _call: CreateSwapCall;

  constructor(call: CreateSwapCall) {
    this._call = call;
  }

  get swap(): CreateSwapCallSwapStruct {
    return changetype<CreateSwapCallSwapStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class CreateSwapCall__Outputs {
  _call: CreateSwapCall;

  constructor(call: CreateSwapCall) {
    this._call = call;
  }

  get value0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class CreateSwapCallSwapStruct extends ethereum.Tuple {
  get owner(): Address {
    return this[0].toAddress();
  }

  get allowed(): Address {
    return this[1].toAddress();
  }

  get expiry(): BigInt {
    return this[2].toBigInt();
  }

  get biding(): Array<CreateSwapCallSwapBidingStruct> {
    return this[3].toTupleArray<CreateSwapCallSwapBidingStruct>();
  }

  get asking(): Array<CreateSwapCallSwapAskingStruct> {
    return this[4].toTupleArray<CreateSwapCallSwapAskingStruct>();
  }
}

export class CreateSwapCallSwapBidingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}

export class CreateSwapCallSwapAskingStruct extends ethereum.Tuple {
  get addr(): Address {
    return this[0].toAddress();
  }

  get amountOrId(): BigInt {
    return this[1].toBigInt();
  }
}
